<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>GET: the First Verb - Cartography: Mapping REST APIs</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="An exploration of a portable technique for creating REST API clients">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="ch00-00-howdy.html">Howdy</a></li><li><a href="ch01-00-getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li><a href="ch01-01-gathering_information.html"><strong aria-hidden="true">1.1.</strong> Gathering Information</a></li><li><a href="ch01-02-initial_specification.html"><strong aria-hidden="true">1.2.</strong> Initial Specification</a></li></ol></li><li><a href="ch02-01-get_the_first_verb.html" class="active"><strong aria-hidden="true">2.</strong> GET: the First Verb</a></li><li><a href="ch03-01-post_the_reverbening.html"><strong aria-hidden="true">3.</strong> POST: the Reverbening</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Cartography: Mapping REST APIs</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="ch02-01-get_the_first_verb.html#get-the-first-verb" id="get-the-first-verb"><h1>GET: the First Verb</h1></a>
<p>I like to start my implementation with the first, least-destructive HTTP verb in mind: <code>GET</code>.</p>
<p>So, let's get started developing our <code>Client</code> class. Why am I using a class here? Aside from the general <em>when in Rome ...</em> rule (though I'm told that it's almost bad form to do OOP in this OO language, by somebody who's probably trollin'), I have some plans down the line for how this client will be used. Also, our requirements flat out state that we need to keep track of some data: the base URL for the API and an authentication token.</p>
<p>Let's start there! In <code>maury/client.py</code>, we'll put the following:</p>
<pre><code class="language-python">class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url = 'https://api.engineyard.com', token = None):
        &quot;&quot;&quot;Set up a Client instance

        Positional arguments:
        base_url -- the base URL of the API (default: 'https://api.engineyard.com')
        token -- the API authentication token (default: None)
        &quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token
</code></pre>
<p>There we go. We now have a <code>Client</code> class that accepts a base URL and a token. Our work is done!</p>
<a class="header" href="ch02-01-get_the_first_verb.html#constructing-urls" id="constructing-urls"><h2>Constructing URLs</h2></a>
<p>Dangit. Okay. More work it is.</p>
<p>Our requirements say that we need to be able to construct URLs based off of a relative endpoint path. So, let's do that in <code>maury/client.py</code>, too:</p>
<pre><code class="language-python">from furl import furl

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set up a Client instance

        Positional arguments:
        base_url -- the base URL of the API
        token -- the API authentication token
        &quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url
</code></pre>
<p>Well, that was easy. That's two requirements down ... let's go for a third.</p>
<a class="header" href="ch02-01-get_the_first_verb.html#speaking-http" id="speaking-http"><h2>Speaking HTTP</h2></a>
<p>We need to be able to speak HTTP! Back to <code>maury/client.py</code>:</p>
<pre><code class="language-python">from furl import furl
import requests

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set up a Client instance

        Positional arguments:
        base_url -- the base URL of the API
        token -- the API authentication token
        &quot;&quot;&quot;


        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url
</code></pre>
<p>It's almost cheating, but simply importing the <code>requests</code> package means that we can speak HTTP in this module. Moving on ...</p>
<a class="header" href="ch02-01-get_the_first_verb.html#http-get" id="http-get"><h2>HTTP GET</h2></a>
<p>This might be the most complicated requirement that we've tackled so far, and it's not the lowest-hanging fruit on the list of remaining requirements, but it makes sense to do this next because of reasons.</p>
<p>So, let's implement the first public method in our <code>Client</code> class: <code>get</code>:</p>
<pre><code class="language-python">from furl import furl
import requests

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set up a Client instance

        Positional arguments:
        base_url -- the base URL of the API
        token -- the API authentication token
        &quot;&quot;&quot;


        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params=params)

        return response.text
</code></pre>
<p>That's fine and good, and it technically fulfills the <code>implements HTTP GET</code> requirement, but there are a few problems with this implementation:</p>
<ul>
<li>It won't work: this is an authenticated API, but we're not handling authentication</li>
<li>It might not work: we haven't specified an API version</li>
<li>It might not work: we are assuming that the API is always in top notch operational condition and that we are always sending a valid request ... there is no error handling at all</li>
</ul>
<p>Let's fix those in that order.</p>
<a class="header" href="ch02-01-get_the_first_verb.html#authentication" id="authentication"><h2>Authentication</h2></a>
<p>So, in order to provide our authentication token to the API, we either have to pass it in as part of the query string, or we have to set the <code>X-EY-TOKEN</code> header. Between the two of these, the header option is more secure and just plain less messy, so let's do that.</p>
<pre><code class="language-python">from furl import furl
import requests

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set the base_url and token for a new Client instance&quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params = params,
                headers = {'X-EY-TOKEN' : self.__token})

        return response.text
</code></pre>
<p>That's taken care of. Next up is to specify the API version.</p>
<a class="header" href="ch02-01-get_the_first_verb.html#api-version" id="api-version"><h2>API Version</h2></a>
<p>In order to specify the version of the API that we want to use, we have to pass it in as part of the <code>Accept</code> header.</p>
<pre><code class="language-python">from furl import furl
import requests

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set the base_url and token for a new Client instance&quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params = params,
                headers = {
                    'X-EY-TOKEN' : self.__token,
                    'accept' : 'application/vnd.engineyard.v3+json',
                    })

        return response.text
</code></pre>
<p>We specified the heck out of that API version, I reckon. One more to go!</p>
<a class="header" href="ch02-01-get_the_first_verb.html#api-error-handling" id="api-error-handling"><h2>API Error Handling</h2></a>
<p>This one might seem a bit weird if you're actually familiar with Python, but since I'm not particularly, I'm going to do the thing that makes the most sense to me, heavily influenced by other languages that I know better.</p>
<p>You see, the thing here is that I don't actually know much about how to handle exceptions in Python, and I actually don't like using exceptions for error handling. Some of my favorite languages use some form of multiple return for error handling. While I could do that with a <code>list</code> or a <code>tuple</code>, there's a technique that I prefer: let's make a <code>Result</code> class in <code>maury/result.py</code>:</p>
<pre><code class="language-python">class Result(object):
    &quot;&quot;&quot;The result of an operation.

    A result has two parts: a body, and an error.
    If the result contains an error, things are not ok.
    If the result contains no error, things are ok.
    &quot;&quot;&quot;

    def __init__(self, body, error):
        &quot;&quot;&quot;Set up a new Result.

        Positional arguments:
        body -- the content to pass along if things are ok
        error -- the content to pass along if things are not ok
        &quot;&quot;&quot;

        self.__body = body
        self.__error = error

    @property
    def ok(self):
        &quot;&quot;&quot;Are things ok?

        If the result has an error, this is false. Otherwise, true.
        &quot;&quot;&quot;

        return self.__error == None

    @property
    def body(self):
        &quot;&quot;&quot;The positive result content&quot;&quot;&quot;

        if self.ok:
            return self.__body

        return None

    @property
    def error(self):
        &quot;&quot;&quot;The negative result content&quot;&quot;&quot;
        return self.__error
</code></pre>
<p>Now that we have a way to express both positive and negative results, let's tie it in and use it in our <code>Client</code>:</p>
<pre><code class="language-python">from furl import furl
import requests
from .result import Result

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set the base_url and token for a new Client instance&quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params = params,
                headers = {
                    'X-EY-TOKEN' : self.__token,
                    'accept' : 'application/vnd.engineyard.v3+json',
                    })

        if r.ok:
            return Result(r.text, None)

        return Result(
                None,
                &quot;The API returned the following status: %d&quot; % r.status_code
                )
</code></pre>
<p>There we go. This feels more like something that will actually work. I should probably prove that with some tests ...</p>
<a class="header" href="ch02-01-get_the_first_verb.html#testing-the-client" id="testing-the-client"><h2>Testing the Client</h2></a>
<p>Usually, I do most all of my development in a test-driven (or test-first) manner, but when I'm learning a new language, I prefer to get used to the language before I try to get used to its testing mechanisms. At any rate, let's write our first test.</p>
<p>Since we're testing the client, we should probably figure out a way to mock out the actual HTTP requests. Otherwise, we're going to have to be online to run our tests, which is kind of a drag. It turns out, though, that <a href="http://requests-mock.readthedocs.io/en/latest/">requests-mock</a> is a thing, so let's pull that into our test requirements in <code>setup.py</code>:</p>
<pre><code class="language-python">from setuptools import setup

install_requires=[
    'furl',
    'requests',
    ]

tests_require = [
    'mock',
    'nose',
    'requests-mock',
    ]

setup(
        name = 'maury',
        version = '0.1.0',
        description = 'A experimental client for the Engine Yard API',
        license = 'MIT',
        packages = ['maury'],
        install_requires = install_requires,
        tests_require = tests_require,
        test_suite = &quot;nose.collector&quot;,
        zip_safe = False)
</code></pre>
<p>So far, so good. Now let's try actually writing a test or two in <code>tests/test_client.py</code>:</p>
<pre><code class="language-python">from unittest import TestCase
import requests_mock

from maury.client import Client

class TestResult(TestCase):
    @requests_mock.Mocker()
    def test_get(self, m):
        # The happy path
        m.get('https://api.engineyard.com/sausages', text='gold')

        c = Client('https://api.engineyard.com', 'faketoken')
        result = c.get('sausages', None)
        self.assertTrue(result.ok)
        self.assertEqual(result.body, 'gold')

        # The happy path with params
        m.get('https://api.engineyard.com/sausages?color=gold', text='yep')

        result = c.get('sausages', {'color' : 'gold'})
        self.assertTrue(result.ok)
        self.assertEqual(result.body, 'yep')

        # A wild API error appears!
        m.get(
                'https://api.engineyard.com/ed209',
                status_code = 500,
                text = 'Drop your weapon. You have 20 seconds to comply.')

        result = c.get('ed209', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)

        # PEBCAK
        m.get(
                'https://api.engineyard.com/404',
                status_code = 404,
                text = 'You are now staring into the void. It is staring back.')

        result = c.get('404', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)
</code></pre>
<p>When we run our tests with <code>python setup.py test</code>, we get (along with a ton of noise) the following output:</p>
<pre><code>test_get (maury.tests.test_client.TestResult) ... ok
</code></pre>
<p>That sounds like a winner in my book. There are still a few things we should straighten out before we move on, though. First thing being first ... textual responses are fine and all, but we're really more interested in JSON responses.</p>
<a class="header" href="ch02-01-get_the_first_verb.html#json" id="json"><h2>JSON</h2></a>
<p>The <code>requests</code> package is nice enough to automagically convert JSON responses for us, so let's change the tests for that.</p>
<pre><code class="language-python">from unittest import TestCase
import requests_mock

from maury.client import Client

class TestResult(TestCase):
    @requests_mock.Mocker()
    def test_get(self, m):
        # The happy path
        m.get('https://api.engineyard.com/sausages', text='{&quot;sausages&quot;:&quot;gold&quot;}')

        c = Client('https://api.engineyard.com', 'faketoken')
        result = c.get('sausages', None)
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'gold'})

        # The happy path with params
        m.get(
                'https://api.engineyard.com/sausages?color=gold',
                text='{&quot;sausages&quot;:&quot;yep&quot;}')

        result = c.get('sausages', {'color' : 'gold'})
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'yep'})

        # A wild API error appears!
        m.get(
                'https://api.engineyard.com/ed209',
                status_code = 500,
                text = 'Drop your weapon. You have 20 seconds to comply.')

        result = c.get('ed209', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)

        # PEBCAK
        m.get(
                'https://api.engineyard.com/404',
                status_code = 404,
                text = 'You are now staring into the void. It is staring back.')

        result = c.get('404', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)
</code></pre>
<p>If we run the tests right now, we get failures. That's because we changed the test specification, but we haven't changed the code yet. That's awesome, because that's the sort of test-driven thing that allows us to actually change the code intentionally (rather than otherwise). So, let's intentionally change <code>maury/client.py</code> so we get JSON in our results instead of raw text:</p>
<pre><code class="language-python">from furl import furl
import requests
from .result import Result

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set the base_url and token for a new Client instance&quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params = params,
                headers = {
                    'X-EY-TOKEN' : self.__token,
                    'accept' : 'application/vnd.engineyard.v3+json',
                    'content-type' : 'application/json',
                    })

        if r.ok:
            return Result(r.json(), None)

        return Result(
                None,
                &quot;The API returned the following status: %d&quot; % r.status_code
                )
</code></pre>
<p>Now that we've updated the client, the tests pass again. Sometimes, I do love developering. As you can see, we've also specified that we would like JSON back in our responses via the headers for the request.</p>
<p>There's one last bit of business to take care of before we consider this iteration complete.</p>
<a class="header" href="ch02-01-get_the_first_verb.html#revisiting-result" id="revisiting-result"><h2>Revisiting Result</h2></a>
<p>The <code>Result</code> class looks good. It gives us a clean way to communicate back to the code that's using our <code>Client</code>. But does it? We should illustrate that with a test in <code>tests/test_result.py</code>:</p>
<pre><code class="language-python">from unittest import TestCase

from maury.result import Result

class TestResult(TestCase):
    def test_ok(self):
        good = Result('yay', None)
        bad = Result(None, 'uh-oh')

        self.assertTrue(good.ok)
        self.assertFalse(bad.ok)

    def test_body(self):
        body = &quot;head and shoulders, knees and toes&quot;
        result = Result(body, None)

        self.assertEqual(result.body, body)

        result = Result(body, 'Onoes!')

        self.assertEqual(result.body, None)

    def test_error(self):
        body = 'eyes and ears and mouth and nose'
        error = &quot;I've made a terrible mistake&quot;
        result = Result(body, error)

        self.assertEqual(result.error, error)
</code></pre>
<p>That does it. If all our client ever has to do is provide the ability to make <code>GET</code> requests against the API, we're done!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch01-02-initial_specification.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch03-01-post_the_reverbening.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="ch01-02-initial_specification.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="ch03-01-post_the_reverbening.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
