<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Cartography: Mapping REST APIs</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="An exploration of a portable technique for creating REST API clients">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme;
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            document.querySelector('html').classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="ch00/00-howdy.html">Howdy</a></li><li><a href="ch01/00-getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li><a href="ch01/01-gathering_information.html"><strong aria-hidden="true">1.1.</strong> Gathering Information</a></li><li><a href="ch01/02-initial_specification.html"><strong aria-hidden="true">1.2.</strong> Initial Specification</a></li></ol></li><li><a href="ch02/00-implementing_a_driver.html"><strong aria-hidden="true">2.</strong> Implementing A Driver</a></li><li><ol class="section"><li><a href="ch02/01-get_the_first_verb.html"><strong aria-hidden="true">2.1.</strong> GET: the First Verb</a></li><li><a href="ch02/02-post_the_reverbening.html"><strong aria-hidden="true">2.2.</strong> POST: the Reverbening</a></li><li><a href="ch02/03-put_patch_the_verb_legacy.html"><strong aria-hidden="true">2.3.</strong> PUT/PATCH: the Verb Legacy</a></li><li><a href="ch02/04-delete_the_final_verb.html"><strong aria-hidden="true">2.4.</strong> DELETE: the Final Verb</a></li></ol></li><li><a href="ch03/00-handling_endpoints.html"><strong aria-hidden="true">3.</strong> Handling Endpoints</a></li><li><ol class="section"><li><a href="ch03/01-users.html"><strong aria-hidden="true">3.1.</strong> Users</a></li><li><a href="ch03/02-accounts.html"><strong aria-hidden="true">3.2.</strong> Accounts</a></li><li><a href="ch03/03-environments.html"><strong aria-hidden="true">3.3.</strong> Environments</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                        </div>

                        <h1 class="menu-title">Cartography: Mapping REST APIs</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#howdy" id="howdy"><h1>Howdy!</h1></a>
<p>Have you ever wanted to create your very own client for a REST API? That's what this book is all about.</p>
<p>Why &quot;cartography?&quot; Well, a lot of the REST APIs out there, regardless of how well documented they may be, require for us to do a bit of journeying and mapping along the way to figure out how things really work. A lot of the time, the API provider will go ahead and publish clients for the popular languages of the day because of the above conundrum, but that isn't always the case.</p>
<p>For example, the <a href="https://developer.engineyard.com">Engine Yard API</a> is relatively well-documented, and Engine Yard does provide <a href="https://github.com/engineyard/core-client-rb">a Ruby client</a>, but what if I want to consume this API from a Python program?</p>
<p>That is the example that we'll use for the purposes of this illustration: implementing a Python client for the Engine Yard API. That said, the techniques used here should be fairly easily adapated to most any language or API.</p>
<a class="header" href="print.html#a-few-caveats" id="a-few-caveats"><h2>A Few Caveats</h2></a>
<p>As seems to be the case with all books like this one, there are a few things that should probably be stated up front:</p>
<ul>
<li>I'm currently employed by <a href="https://www.engineyard.com">Engine Yard</a> as a Professional Services Engineer, which is really just a fancy way to say that I do the &quot;whatever it takes&quot; on behalf of customers that need very custom setups. The use of the Engine Yard API as the example for this book is mostly because it is a somehat complicated (to the point of being difficult) API to consume.</li>
<li>This very much is not the only way that one could develop an API client. This is, however, the method that I prefer, so I'm rolling with it.</li>
<li>Python is being used as the implementation language in this book, but this is just an example of a language that is not officially supported by the API provider. As it were, there are partial implementations of the client that is being developed in this book in the following languages: Go, Javascript, ooc, Ruby, Rust</li>
<li>I don't actually know Python, so this will be a learning experience for me as well. I'm using Python 3.6.4 locally to develop this client as we go, but it's important to note that this should probably not be considered an example of idiomatic Python code, let alone high-quality Python code. I honestly don't know Python well enough to even be able to make that previous statement.</li>
</ul>
<a class="header" href="print.html#getting-started" id="getting-started"><h1>Getting Started</h1></a>
<p>This chapter is all about doing the very first things that I do when staring this sort of project. It's not really about installing Python, setting up a new project space, or anything like that. More so, it's about what happens after all of those things.</p>
<p>The first step in the process, at least for me, is to take a look at whatever documentation may exist for the API that I'm trying to map to see if I can find some basic hints for its usage.</p>
<a class="header" href="print.html#gathering-information" id="gathering-information"><h1>Gathering Information</h1></a>
<p>In the case of the Engine Yard API, there's actually quite a lot of information that we can get from the <a href="https://developer.engineyard.com">API overview</a>:</p>
<ul>
<li>It's an authenticated HTTP API</li>
<li>The authentication token can be passed in either as part of the query or as the <code>X-EY-TOKEN</code> request header</li>
<li>From this page, we know that the <code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>PATCH</code> HTTP verbs are used</li>
<li>We know that the API can both accept and serve the <code>application/json</code> MIME type</li>
<li>From the sidebar, we can see that there are a good number of endpoints off of the API root</li>
</ul>
<p>Taking a look around at some of those endpoints, we learn even more about this specific API:</p>
<ul>
<li>The API is versioned</li>
<li>The desired API version is specified as part of the <code>Accept</code> request header: <code>application/vnd.engineyard.v3+json</code></li>
<li>The <code>DELETE</code> HTTP verb is also used in this API</li>
</ul>
<a class="header" href="print.html#initial-specification" id="initial-specification"><h1>Initial Specification</h1></a>
<p>Now that we have done a bit of investigation and know a few things about the API with which we're working, we should put the results of that investigation to use.</p>
<p>First off, we need to name the project. In keeping with the naming for my other EY API client implementations, I've called this project <a href="https://en.wikipedia.org/wiki/Maurice_W._Graham">maury</a>, but you can call it anything that you'd like.</p>
<a class="header" href="print.html#client-requirements" id="client-requirements"><h2>Client Requirements</h2></a>
<p>Now that the hardest part of any project is over with, we should identify the base requirements for our core client driver:</p>
<ul>
<li>It must speak HTTP</li>
<li>It must accept an authentication token</li>
<li>For the sake of flexibility, it should also accept the base URL for the API</li>
<li>It must be able to use the HTTP verbs in question</li>
<li>It must be able to set the <code>X-EY-TOKEN</code>, <code>Content-Type</code>, and <code>Accept</code> headers</li>
<li>For convenience, it should treat all requests as relative, so it must be able to build URLs for each request</li>
</ul>
<p>That doesn't really sound like a lot, but the driver that we implement through the rest of this chapter is all we <em>really</em> need to work with the API. Don't worry, we're not stopping there at all. We have to crawl before we can walk, though.</p>
<a class="header" href="print.html#library-support" id="library-support"><h2>Library Support</h2></a>
<p>Technically, all of the things that we need in order to implement the core client driver is provided in the Python standard library. That being the case, after a quick google around, it looks like the community has decided on a better alternative to the HTTP client provided by std: <a href="http://docs.python-requests.org/en/master/">requests</a>.</p>
<p>Additionally, after a bit of quick playing around with the URL parser provided by the standard library, I learned that I can't actually use it to build a URL, which is at least a little important, given that we need to build a URL for every request that the driver handles. More googling led me to the <a href="https://github.com/gruns/furl">furl</a> package.</p>
<p>Finally, we're going to use <a href="http://nose.readthedocs.io/en/latest/">nose</a> to make writing and running our tests easier. Oh, yeah, we're testing. I'd hate for <a href="https://twitter.com/bryanl">Bryan Liles</a> to come after me for showing you how to do this stuff without showing you how I TAFT.</p>
<p>So, now that we have some requirements, let's add them to our <code>setup.py</code>:</p>
<pre><code class="language-python">from setuptools import setup

install_requires=[
    'furl',
    'requests',
    ]

tests_require = [
    'mock',
    'nose',
    'requests-mock',
    ]

setup(
        name = 'maury',
        version = '0.1.0',
        description = 'A experimental client for the Engine Yard API',
        license = 'MIT',
        packages = ['maury'],
        install_requires = install_requires,
        tests_require = tests_require,
        test_suite = &quot;nose.collector&quot;,
        zip_safe = False)

</code></pre>
<a class="header" href="print.html#implementing-a-driver" id="implementing-a-driver"><h1>Implementing A Driver</h1></a>
<a class="header" href="print.html#get-the-first-verb" id="get-the-first-verb"><h1>GET: the First Verb</h1></a>
<p>I like to start my implementation with the first, least-destructive HTTP verb in mind: <code>GET</code>.</p>
<p>So, let's get started developing our <code>Client</code> class. Why am I using a class here? Aside from the general <em>when in Rome ...</em> rule (though I'm told that it's almost bad form to do OOP in this OO language, by somebody who's probably trollin'), I have some plans down the line for how this client will be used. Also, our requirements flat out state that we need to keep track of some data: the base URL for the API and an authentication token.</p>
<p>Let's start there! In <code>maury/client.py</code>, we'll put the following:</p>
<pre><code class="language-python">class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url = 'https://api.engineyard.com', token = None):
        &quot;&quot;&quot;Set up a Client instance

        Positional arguments:
        base_url -- the base URL of the API (default: 'https://api.engineyard.com')
        token -- the API authentication token (default: None)
        &quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token
</code></pre>
<p>There we go. We now have a <code>Client</code> class that accepts a base URL and a token. Our work is done!</p>
<a class="header" href="print.html#constructing-urls" id="constructing-urls"><h2>Constructing URLs</h2></a>
<p>Dangit. Okay. More work it is.</p>
<p>Our requirements say that we need to be able to construct URLs based off of a relative endpoint path. So, let's do that in <code>maury/client.py</code>, too:</p>
<pre><code class="language-python">from furl import furl

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set up a Client instance

        Positional arguments:
        base_url -- the base URL of the API
        token -- the API authentication token
        &quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url
</code></pre>
<p>Well, that was easy. That's two requirements down ... let's go for a third.</p>
<a class="header" href="print.html#speaking-http" id="speaking-http"><h2>Speaking HTTP</h2></a>
<p>We need to be able to speak HTTP! Back to <code>maury/client.py</code>:</p>
<pre><code class="language-python">from furl import furl
import requests

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set up a Client instance

        Positional arguments:
        base_url -- the base URL of the API
        token -- the API authentication token
        &quot;&quot;&quot;


        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url
</code></pre>
<p>It's almost cheating, but simply importing the <code>requests</code> package means that we can speak HTTP in this module. Moving on ...</p>
<a class="header" href="print.html#http-get" id="http-get"><h2>HTTP GET</h2></a>
<p>This might be the most complicated requirement that we've tackled so far, and it's not the lowest-hanging fruit on the list of remaining requirements, but it makes sense to do this next because of reasons.</p>
<p>So, let's implement the first public method in our <code>Client</code> class: <code>get</code>:</p>
<pre><code class="language-python">from furl import furl
import requests

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set up a Client instance

        Positional arguments:
        base_url -- the base URL of the API
        token -- the API authentication token
        &quot;&quot;&quot;


        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params=params)

        return response.text
</code></pre>
<p>That's fine and good, and it technically fulfills the <code>implements HTTP GET</code> requirement, but there are a few problems with this implementation:</p>
<ul>
<li>It won't work: this is an authenticated API, but we're not handling authentication</li>
<li>It might not work: we haven't specified an API version</li>
<li>It might not work: we are assuming that the API is always in top notch operational condition and that we are always sending a valid request ... there is no error handling at all</li>
</ul>
<p>Let's fix those in that order.</p>
<a class="header" href="print.html#authentication" id="authentication"><h2>Authentication</h2></a>
<p>So, in order to provide our authentication token to the API, we either have to pass it in as part of the query string, or we have to set the <code>X-EY-TOKEN</code> header. Between the two of these, the header option is more secure and just plain less messy, so let's do that.</p>
<pre><code class="language-python">from furl import furl
import requests

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set the base_url and token for a new Client instance&quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params = params,
                headers = {'X-EY-TOKEN' : self.__token})

        return response.text
</code></pre>
<p>That's taken care of. Next up is to specify the API version.</p>
<a class="header" href="print.html#api-version" id="api-version"><h2>API Version</h2></a>
<p>In order to specify the version of the API that we want to use, we have to pass it in as part of the <code>Accept</code> header.</p>
<pre><code class="language-python">from furl import furl
import requests

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set the base_url and token for a new Client instance&quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params = params,
                headers = {
                    'X-EY-TOKEN' : self.__token,
                    'accept' : 'application/vnd.engineyard.v3+json',
                    })

        return response.text
</code></pre>
<p>We specified the heck out of that API version, I reckon. One more to go!</p>
<a class="header" href="print.html#api-error-handling" id="api-error-handling"><h2>API Error Handling</h2></a>
<p>This one might seem a bit weird if you're actually familiar with Python, but since I'm not particularly, I'm going to do the thing that makes the most sense to me, heavily influenced by other languages that I know better.</p>
<p>You see, the thing here is that I don't actually know much about how to handle exceptions in Python, and I actually don't like using exceptions for error handling. Some of my favorite languages use some form of multiple return for error handling. While I could do that with a <code>list</code> or a <code>tuple</code>, there's a technique that I prefer: let's make a <code>Result</code> class in <code>maury/result.py</code>:</p>
<pre><code class="language-python">class Result(object):
    &quot;&quot;&quot;The result of an operation.

    A result has two parts: a body, and an error.
    If the result contains an error, things are not ok.
    If the result contains no error, things are ok.
    &quot;&quot;&quot;

    def __init__(self, body, error):
        &quot;&quot;&quot;Set up a new Result.

        Positional arguments:
        body -- the content to pass along if things are ok
        error -- the content to pass along if things are not ok
        &quot;&quot;&quot;

        self.__body = body
        self.__error = error

    @property
    def ok(self):
        &quot;&quot;&quot;Are things ok?

        If the result has an error, this is false. Otherwise, true.
        &quot;&quot;&quot;

        return self.__error == None

    @property
    def body(self):
        &quot;&quot;&quot;The positive result content&quot;&quot;&quot;

        if self.ok:
            return self.__body

        return None

    @property
    def error(self):
        &quot;&quot;&quot;The negative result content&quot;&quot;&quot;
        return self.__error
</code></pre>
<p>Now that we have a way to express both positive and negative results, let's tie it in and use it in our <code>Client</code>:</p>
<pre><code class="language-python">from furl import furl
import requests
from .result import Result

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set the base_url and token for a new Client instance&quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params = params,
                headers = {
                    'X-EY-TOKEN' : self.__token,
                    'accept' : 'application/vnd.engineyard.v3+json',
                    })

        if r.ok:
            return Result(r.text, None)

        return Result(
                None,
                &quot;The API returned the following status: %d&quot; % r.status_code
                )
</code></pre>
<p>There we go. This feels more like something that will actually work. I should probably prove that with some tests ...</p>
<a class="header" href="print.html#testing-the-client" id="testing-the-client"><h2>Testing the Client</h2></a>
<p>Usually, I do most all of my development in a test-driven (or test-first) manner, but when I'm learning a new language, I prefer to get used to the language before I try to get used to its testing mechanisms. At any rate, let's write our first test.</p>
<p>Since we're testing the client, we should probably figure out a way to mock out the actual HTTP requests. Otherwise, we're going to have to be online to run our tests, which is kind of a drag. It turns out, though, that <a href="http://requests-mock.readthedocs.io/en/latest/">requests-mock</a> is a thing, so let's pull that into our test requirements in <code>setup.py</code>:</p>
<pre><code class="language-python">from setuptools import setup

install_requires=[
    'furl',
    'requests',
    ]

tests_require = [
    'mock',
    'nose',
    'requests-mock',
    ]

setup(
        name = 'maury',
        version = '0.1.0',
        description = 'A experimental client for the Engine Yard API',
        license = 'MIT',
        packages = ['maury'],
        install_requires = install_requires,
        tests_require = tests_require,
        test_suite = &quot;nose.collector&quot;,
        zip_safe = False)
</code></pre>
<p>So far, so good. Now let's try actually writing a test or two in <code>tests/test_client.py</code>:</p>
<pre><code class="language-python">from unittest import TestCase
import requests_mock

from maury.client import Client

class TestResult(TestCase):
    @requests_mock.Mocker()
    def test_get(self, m):
        # The happy path
        m.get('https://api.engineyard.com/sausages', text='gold')

        c = Client('https://api.engineyard.com', 'faketoken')
        result = c.get('sausages', None)
        self.assertTrue(result.ok)
        self.assertEqual(result.body, 'gold')

        # The happy path with params
        m.get('https://api.engineyard.com/sausages?color=gold', text='yep')

        result = c.get('sausages', {'color' : 'gold'})
        self.assertTrue(result.ok)
        self.assertEqual(result.body, 'yep')

        # A wild API error appears!
        m.get(
                'https://api.engineyard.com/ed209',
                status_code = 500,
                text = 'Drop your weapon. You have 20 seconds to comply.')

        result = c.get('ed209', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)

        # PEBCAK
        m.get(
                'https://api.engineyard.com/404',
                status_code = 404,
                text = 'You are now staring into the void. It is staring back.')

        result = c.get('404', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)
</code></pre>
<p>When we run our tests with <code>python setup.py test</code>, we get (along with a ton of noise) the following output:</p>
<pre><code>test_get (maury.tests.test_client.TestResult) ... ok
</code></pre>
<p>That sounds like a winner in my book. There are still a few things we should straighten out before we move on, though. First thing being first ... textual responses are fine and all, but we're really more interested in JSON responses.</p>
<a class="header" href="print.html#json" id="json"><h2>JSON</h2></a>
<p>The <code>requests</code> package is nice enough to automagically convert JSON responses for us, so let's change the tests for that.</p>
<pre><code class="language-python">from unittest import TestCase
import requests_mock

from maury.client import Client

class TestResult(TestCase):
    @requests_mock.Mocker()
    def test_get(self, m):
        # The happy path
        m.get('https://api.engineyard.com/sausages', text='{&quot;sausages&quot;:&quot;gold&quot;}')

        c = Client('https://api.engineyard.com', 'faketoken')
        result = c.get('sausages', None)
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'gold'})

        # The happy path with params
        m.get(
                'https://api.engineyard.com/sausages?color=gold',
                text='{&quot;sausages&quot;:&quot;yep&quot;}')

        result = c.get('sausages', {'color' : 'gold'})
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'yep'})

        # A wild API error appears!
        m.get(
                'https://api.engineyard.com/ed209',
                status_code = 500,
                text = 'Drop your weapon. You have 20 seconds to comply.')

        result = c.get('ed209', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)

        # PEBCAK
        m.get(
                'https://api.engineyard.com/404',
                status_code = 404,
                text = 'You are now staring into the void. It is staring back.')

        result = c.get('404', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)
</code></pre>
<p>If we run the tests right now, we get failures. That's because we changed the test specification, but we haven't changed the code yet. That's awesome, because that's the sort of test-driven thing that allows us to actually change the code intentionally (rather than otherwise). So, let's intentionally change <code>maury/client.py</code> so we get JSON in our results instead of raw text:</p>
<pre><code class="language-python">from furl import furl
import requests
from .result import Result

class Client(object):
    &quot;&quot;&quot;A base driver that talks to the Engine Yard API&quot;&quot;&quot;

    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set the base_url and token for a new Client instance&quot;&quot;&quot;

        self.__base_url = base_url
        self.__token = token

    def __construct_request_url(self, path):
        &quot;&quot;&quot;Construct a URL for an API endpoint.
        
        Given a relative endpoint path, construct a fully-qualified API URL.
        &quot;&quot;&quot;

        # Get a URL object that we can edit
        u = furl(self.__base_url)

        # Set the path to the endpoint in question
        u.path = path

        # Return the modified URL
        return u.url

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params = params,
                headers = {
                    'X-EY-TOKEN' : self.__token,
                    'accept' : 'application/vnd.engineyard.v3+json',
                    'content-type' : 'application/json',
                    })

        if r.ok:
            return Result(r.json(), None)

        return Result(
                None,
                &quot;The API returned the following status: %d&quot; % r.status_code
                )
</code></pre>
<p>Now that we've updated the client, the tests pass again. Sometimes, I do love developering. As you can see, we've also specified that we would like JSON back in our responses via the headers for the request.</p>
<p>There's one last bit of business to take care of before we consider this iteration complete.</p>
<a class="header" href="print.html#revisiting-result" id="revisiting-result"><h2>Revisiting Result</h2></a>
<p>The <code>Result</code> class looks good. It gives us a clean way to communicate back to the code that's using our <code>Client</code>. But does it? We should illustrate that with a test in <code>tests/test_result.py</code>:</p>
<pre><code class="language-python">from unittest import TestCase

from maury.result import Result

class TestResult(TestCase):
    def test_ok(self):
        good = Result('yay', None)
        bad = Result(None, 'uh-oh')

        self.assertTrue(good.ok)
        self.assertFalse(bad.ok)

    def test_body(self):
        body = &quot;head and shoulders, knees and toes&quot;
        result = Result(body, None)

        self.assertEqual(result.body, body)

        result = Result(body, 'Onoes!')

        self.assertEqual(result.body, None)

    def test_error(self):
        body = 'eyes and ears and mouth and nose'
        error = &quot;I've made a terrible mistake&quot;
        result = Result(body, error)

        self.assertEqual(result.error, error)
</code></pre>
<p>That does it. If all our client ever has to do is provide the ability to make <code>GET</code> requests against the API, we're done!</p>
<a class="header" href="print.html#post-the-reverbening" id="post-the-reverbening"><h1>POST: the Reverbening</h1></a>
<p>Of course, our requirements state that we have to also be able to make <code>POST</code> requests to the API. So, we have more work cut out for us. Luckily, the handling of any given verb is quite a lot like the handling of any other given verb.</p>
<a class="header" href="print.html#a-note-from-our-sponsors" id="a-note-from-our-sponsors"><h2>A Note From Our Sponsors</h2></a>
<p>Yeah, not really. More than anything, I wanted to take this opportunity to let you know that from this point on, listing the entirety of the referenced files would become unwieldy rather quickly.</p>
<p>So, from now on, I'll just show the changes in the code examples instead of the entire file, where possible.</p>
<a class="header" href="print.html#test-driven" id="test-driven"><h2>Test-Driven</h2></a>
<p>Now that we're a little more familiar with the language and its unittest framework, let's change gears a bit. We're going to start our <code>POST</code> feature with a new test in <code>maury/tests/test_client.py</code>:</p>
<pre><code class="language-python">    @requests_mock.Mocker()
    def test_post(self, m):
        # The happy path
        m.post('https://api.engineyard.com/sausages', text='{&quot;sausages&quot;:&quot;gold&quot;}')

        c = Client('https://api.engineyard.com', 'faketoken')
        result = c.post('sausages', None)
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'gold'})

        # The happy path with params
        m.post(
                'https://api.engineyard.com/sausages?color=gold',
                text='{&quot;sausages&quot;:&quot;yep&quot;}')

        result = c.post('sausages', {'color' : 'gold'})
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'yep'})

        # A wild API error appears!
        m.post(
                'https://api.engineyard.com/ed209',
                status_code = 500,
                text = 'Drop your weapon. You have 20 seconds to comply.')

        result = c.post('ed209', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)

        # PEBCAK
        m.post(
                'https://api.engineyard.com/404',
                status_code = 404,
                text = 'You are now staring into the void. It is staring back.')

        result = c.post('404', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)
</code></pre>
<p>As you can see, our <code>post</code> test is almost identical to our <code>get</code> test. That's becuase, as mentioned above, all of the verbs are handled in more or less the same way. The big difference here is that <code>post</code> involves not just a path and a params dict, but also a dict of data to be <code>POST</code>ed to the endpoint.</p>
<p>After running our tests, we see that our <code>test_post</code> test yields an error. That's because we don't have a <code>post</code> method in our client yet. Let's do that.</p>
<a class="header" href="print.html#first-draft-implementation" id="first-draft-implementation"><h2>First Draft Implementation</h2></a>
<p>Since they test the same (aside from the extra argument), it stands to reason that <code>get</code> and <code>post</code> should have rather similar implementations. Let's do a quick copypasta in <code>maury/client.py</code> and see how that works out:</p>
<pre><code class="language-python">    def post(self, path, params, data):
        &quot;&quot;&quot;Perform an HTTP POST on the API.
        
        Given an endpoint path, a dictionary of parameters, and a dictionary of
        POST data, send the request to the API and return the result.
        &quot;&quot;&quot;

        r = requests.post(self.__construct_request_url(path),
                params = params,
                json = data,
                headers = {
                    'X-EY-TOKEN' : self.__token,
                    'accept' : 'application/vnd.engineyard.v3+json',
                    'content-type' : 'application/json',
                    })

        if r.ok:
            return Result(r.json(), None)

        return Result(
                None,
                &quot;The API returned the following status: %d&quot; % r.status_code
                )
</code></pre>
<p>Running our tests now yields a success:</p>
<pre><code>test_post (maury.tests.test_client.TestResult) ... ok
</code></pre>
<p>So, one could argue that we're done at this point, but there's something that's bugging me a bit about this implementation. Take a look at the <code>get</code> and <code>post</code> methods. Notice how similar they are? We should probably take this opportunity to go ahead and refactor those similarities away.</p>
<a class="header" href="print.html#refactoring-response-processor" id="refactoring-response-processor"><h2>Refactoring: Response Processor</h2></a>
<p>So, one of the things that makes these two methods so similar, aside from all verbs being very similar in the first place, is that they both interpret the API response identically. That being the case, we can construct a common method to use for response processing in <code>maury/client.py</code>:</p>
<pre><code class="language-python">    def __process_response(self, response):
        &quot;&quot;&quot;Process an API response into a Result.&quot;&quot;&quot;

        if response.ok:
            return Result(response.json(), None)

        return Result(
                None,
                &quot;The API returned the following status: %d&quot; % response.status_code
                )

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params = params,
                headers = {
                    'X-EY-TOKEN' : self.__token,
                    'accept' : 'application/vnd.engineyard.v3+json',
                    'content-type' : 'application/json',
                    })

        return self.__process_response(r)

    def post(self, path, params, data):
        &quot;&quot;&quot;Perform an HTTP POST on the API.
        
        Given an endpoint path, a dictionary of parameters, and a dictionary of
        POST data, send the request to the API and return the result.
        &quot;&quot;&quot;

        r = requests.post(self.__construct_request_url(path),
                params = params,
                json = data,
                headers = {
                    'X-EY-TOKEN' : self.__token,
                    'accept' : 'application/vnd.engineyard.v3+json',
                    'content-type' : 'application/json',
                    })

        return self.__process_response(r)
</code></pre>
<p>That's a little better, and thanks to our tests, we can see that the behavior has not changed. Yay TDD! Still, I see at least one more thing that I don't like: those repeated headers seem like a perfect aspect to reconsider.</p>
<a class="header" href="print.html#refactoring-headers" id="refactoring-headers"><h2>Refactoring: Headers</h2></a>
<p>Now, there are a lot of ways that we could switch up the request headers dictionary. I usually go for a private method for things like this, but I'm also not familiar enough with Python to know how much of an impact on resource usage and performance constantly generating new dicts will have. That being the case, let's jump into <code>maury/client.py</code> and see if we can find another way:</p>
<pre><code class="language-python">    def __init__(self, base_url, token):
        &quot;&quot;&quot;Set the base_url and token for a new Client instance&quot;&quot;&quot;

        self.__base_url = base_url
        self.__headers = {
                'X-EY-Token' : token,
                'accept' : 'application/vnd.engineyard.com.v3+json',
                'content-type' : 'application/json'
                }

    def get(self, path, params):
        &quot;&quot;&quot;Perform an HTTP GET on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.get(self.__construct_request_url(path),
                params = params,
                headers = self.__headers)

        return self.__process_response(r)

    def post(self, path, params, data):
        &quot;&quot;&quot;Perform an HTTP POST on the API.
        
        Given an endpoint path, a dictionary of parameters, and a dictionary of
        POST data, send the request to the API and return the result.
        &quot;&quot;&quot;

        r = requests.post(self.__construct_request_url(path),
                params = params,
                json = data,
                headers = self.__headers)

        return self.__process_response(r)
</code></pre>
<p>What we did there was to store the headers dictionary directly in the client object as <code>__headers</code>. Also, since we don't use the token for anything else, we are no longer storing the token at all. Also, the tests still pass, so it looks like we're still good.</p>
<a class="header" href="print.html#refacotring-whats-next" id="refacotring-whats-next"><h2>Refacotring: What's Next?</h2></a>
<p>Can we go further? Sure, we can, but at this point, we probably shouldn't.</p>
<p>So far, all verb implementations have involved making an API request, then processing the API response. We have implemented less than half of the verbs that we have to implement, though.</p>
<p>That being the case, let's follow the advice that I'd imagine Sandy Metz would give right now: let's just keep working on the requirements until we're <strong><em>sure</em></strong> that we can safely refactor further.</p>
<a class="header" href="print.html#putpatch-the-verb-legacy" id="putpatch-the-verb-legacy"><h1>PUT/PATCH: the Verb Legacy</h1></a>
<p>While it's not strictly the case, <code>PUT</code> and <code>PATCH</code> are fairly often used interchangeably on REST APIs. Considering this, we're going to go ahead and implement these at the same time.</p>
<a class="header" href="print.html#tests" id="tests"><h2>Tests</h2></a>
<p>Another fortunate bit is that <code>put</code> and <code>patch</code> have the same signature as <code>post</code>. That being the case, let's go ahead and copypasta the <code>post</code> test in <code>maury/tests/test_client.py</code> and modify it for our new methods:</p>
<pre><code class="language-python">    @requests_mock.Mocker()
    def test_put(self, m):
        # The happy path
        m.put('https://api.engineyard.com/sausages', text='{&quot;sausages&quot;:&quot;gold&quot;}')

        c = Client('https://api.engineyard.com', 'faketoken')
        result = c.put('sausages', None, None)
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'gold'})

        # The happy path with params
        m.put(
                'https://api.engineyard.com/sausages?color=gold',
                text='{&quot;sausages&quot;:&quot;yep&quot;}')

        result = c.put('sausages', {'color' : 'gold'}, None)
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'yep'})

        # A wild API error appears!
        m.put(
                'https://api.engineyard.com/ed209',
                status_code = 500,
                text = 'Drop your weapon. You have 20 seconds to comply.')

        result = c.put('ed209', None, None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)

        # PEBCAK
        m.put(
                'https://api.engineyard.com/404',
                status_code = 404,
                text = 'You are now staring into the void. It is staring back.')

        result = c.put('404', None, None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)

    @requests_mock.Mocker()
    def test_patch(self, m):
        # The happy path
        m.patch('https://api.engineyard.com/sausages', text='{&quot;sausages&quot;:&quot;gold&quot;}')

        c = Client('https://api.engineyard.com', 'faketoken')
        result = c.patch('sausages', None, None)
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'gold'})

        # The happy path with params
        m.patch(
                'https://api.engineyard.com/sausages?color=gold',
                text='{&quot;sausages&quot;:&quot;yep&quot;}')

        result = c.patch('sausages', {'color' : 'gold'}, None)
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'yep'})

        # A wild API error appears!
        m.patch(
                'https://api.engineyard.com/ed209',
                status_code = 500,
                text = 'Drop your weapon. You have 20 seconds to comply.')

        result = c.patch('ed209', None, None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)

        # PEBCAK
        m.patch(
                'https://api.engineyard.com/404',
                status_code = 404,
                text = 'You are now staring into the void. It is staring back.')

        result = c.patch('404', None, None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)
</code></pre>
<p>As expected, these tests fail, as we don't yet have either the <code>put</code> or <code>patch</code> mehods in our client.</p>
<a class="header" href="print.html#implementing-the-methods" id="implementing-the-methods"><h2>Implementing the Methods</h2></a>
<p>So, let's crack open <code>maury/client.py</code> again, copypasta the <code>post</code> method, and modify it to fit our new methods:</p>
<pre><code class="language-python">    def put(self, path, params, data):
        &quot;&quot;&quot;Perform an HTTP PUT on the API.
        
        Given an endpoint path, a dictionary of parameters, and a dictionary of
        PUT data, send the request to the API and return the result.
        &quot;&quot;&quot;

        r = requests.put(self.__construct_request_url(path),
                params = params,
                json = data,
                headers = self.__headers)

        return self.__process_response(r)

    def patch(self, path, params, data):
        &quot;&quot;&quot;Perform an HTTP PATCH on the API.
        
        Given an endpoint path, a dictionary of parameters, and a dictionary of
        PATCH data, send the request to the API and return the result.
        &quot;&quot;&quot;

        r = requests.patch(self.__construct_request_url(path),
                params = params,
                json = data,
                headers = self.__headers)

        return self.__process_response(r)
</code></pre>
<p>With that, our tests pass, and we've now implemented 80% of the HTTP verbs that we need to meet our requirements. That means it's time to take another look and decide if we should refactor further.</p>
<a class="header" href="print.html#refactoring-reqeust-handler" id="refactoring-reqeust-handler"><h2>Refactoring: Reqeust Handler</h2></a>
<p>It might seem obvious that since we've already made a common method to handle the processing of an API response that it would also make sense to break out a method that performs the requests in question.</p>
<p>That is a fine observation, and it is indeed what I would usually do myself. The problem here is that my lack of Python knowledge is preventing me from coming up with the best way to do so. So, I'm going to keep on going the way that we have been and leave this refactoring to you, if you choose to do it.</p>
<a class="header" href="print.html#delete-the-final-verb" id="delete-the-final-verb"><h1>DELETE: the Final Verb</h1></a>
<p>Our driver is very nearly complete. We only have one verb left to go, so let's get to it!</p>
<a class="header" href="print.html#test" id="test"><h2>Test</h2></a>
<p>As it would happen, <code>delete</code> has the same signature and expectations as <code>get</code>, so let's go ahead and copypasta <code>test_get</code> and modify it to <code>test_delete</code> in <code>maury/tests/test_client.py</code>:</p>
<pre><code class="language-python">@requests_mock.Mocker()
    def test_delete(self, m):
        # The happy path
        m.delete('https://api.engineyard.com/sausages', text='{&quot;sausages&quot;:&quot;gold&quot;}')

        c = Client('https://api.engineyard.com', 'faketoken')
        result = c.delete('sausages', None)
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'gold'})

        # The happy path with params
        m.delete(
                'https://api.engineyard.com/sausages?color=gold',
                text='{&quot;sausages&quot;:&quot;yep&quot;}')

        result = c.delete('sausages', {'color' : 'gold'})
        self.assertTrue(result.ok)
        self.assertEqual(result.body, {'sausages' : 'yep'})

        # A wild API error appears!
        m.delete(
                'https://api.engineyard.com/ed209',
                status_code = 500,
                text = 'Drop your weapon. You have 20 seconds to comply.')

        result = c.delete('ed209', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)

        # PEBCAK
        m.delete(
                'https://api.engineyard.com/404',
                status_code = 404,
                text = 'You are now staring into the void. It is staring back.')

        result = c.delete('404', None)
        self.assertFalse(result.ok)
        self.assertFalse(result.error == None)
</code></pre>
<p>Okay, we have a failing test now, so we're going to do the obvious.</p>
<a class="header" href="print.html#implementing-delete" id="implementing-delete"><h2>Implementing DELETE</h2></a>
<p>Since the signature is the same as <code>get</code>, we're going to copypasta the <code>get</code> method definition and modify it to fit our new <code>delete</code> method in <code>maury/client.py</code>:</p>
<pre><code class="language-python">    def delete(self, path, params):
        &quot;&quot;&quot;Perform an HTTP DELETE on the API.
        
        Given an endpoint path and a dictionary of parameters, send the request
        to the API and return the result.
        &quot;&quot;&quot;

        r = requests.delete(self.__construct_request_url(path),
                params = params,
                headers = self.__headers)

        return self.__process_response(r)
</code></pre>
<p>There we have it. Now that all of the defined requirements are met and all of our tests pass, our client driver is technically complete.</p>
<a class="header" href="print.html#handling-endpoints" id="handling-endpoints"><h1>Handling Endpoints</h1></a>
<a class="header" href="print.html#users" id="users"><h1>Users</h1></a>
<a class="header" href="print.html#accounts" id="accounts"><h1>Accounts</h1></a>
<a class="header" href="print.html#environments" id="environments"><h1>Environments</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if (getComputedStyle(document.querySelector(".fa")).fontFamily !== "FontAwesome") {
                var link = document.createElement('link');
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = '_FontAwesome/css/font-awesome.css';
                document.head.insertBefore(link, document.head.firstChild)
            }
        </script>

        

        

        

        
        <script>
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
